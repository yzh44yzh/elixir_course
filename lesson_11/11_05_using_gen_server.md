# Использование GenServer

В работе с GenServer есть нюансы. Рассмотрим те, которые важно знать с самого начала:
- отложенная инициализация;
- блокировка (deadlock) на GenServer.call;
- переполнение почтового ящика.


## Отложенная инициализация

Вызов `GenServer.start` блокирует родительский процесс пока не завершится `init` в дочернем процессе. Это может быть нежелательным, если запускается много процессов (что и происходит на старте узла BEAM). 

Если инициализация занимает долгое время, например, когда нам нужно получить какие-то данные из базы или из стороннего сервера, то это лучше сделать не сразу в init, а позже.

Для этого есть обработчик `handle_continue`.

```elixir
@impl true
def init(:no_args) do
  state = %{}
  {:ok, state, {:continue, :delayed_init}}
end

@impl true
def handle_continue(:delayed_init, state) do
  ...
  new_state = init_state(data_file)
  {:noreply, new_state}
end
```

Здесь мы не создаем состояние в init, а быстро отвечаем `:ok`, что позволяет разблокировать родительский процесс. Но после init вызывается обработчик handle_continue, который и выполняет всю инициализацию. 

Здесь маловероятна ситуация, что сервер получит запрос раньше, чем успеет инициализироваться. handle_continue реализован через отправку сообщения самому себе. Это сообщение попадает в почтовый ящик первым и обработается первым, раньше, чем придут запросы от клиентов.

(Маловероятно, но 100% гарантии нет. Кто-то может отправить сообщение по имени процесса, когда он уже запустился, но еще не завершил init. Есть более надёжный, но и более сложный способ отложенной инициализации.)

Аналогично мы можем сделать на `:reload_data` -- очистить текущее состояние и делегировать создание нового состояния в handle_continue, чтобы не дублировать код.

```elixir
@impl true
def handle_continue(:delayed_init, state) do
  ...
  new_state = init_state(data_file)
  {:noreply, new_state}
end

@impl true
def handle_cast(:reload_data, state) do
  # NOTE: don't do `:digraph.delete(graph)` here
  {:noreply, state, {:continue, :delayed_init}}
end
```

Однако здесь вполне возможно, что сервер будет обрабатывать другие запросы после вызова `handle_cast` и до вызова `handle_continue`. Поэтому важно, чтобы state всегда был консистентным на выходе из любого обработчика. 

Поэтому сделать очистку стейта в `handle_cast(:reload_data, ...`, а создание стейта в `handle_continue` будет неправильным.


## Блокировка на GenServer.call

Частая ошибка новичка -- внутри обработчика `handle_call` сделать вызов `GenServer.call` на тот же процесс. Обычно это случается не напрямую, а через вызов публичного АПИ того же модуля:

```elixir
def some_fun() do
  GenServer.call(@server_name, :some_msg)
end

def another_fun() do
  GenServer.call(@server_name, :another_msg)
end

handle_call(:some_msg, _from, state)
  res = another_fun()
  {:reply, res, state}
end
```

В этом случае процесс заблокируется на `res = another_fun()` и будет ждать ответ. `GenServer.call` положит сообщение в почтовый ящик. Но сервер не возьмет это сообщение в обработку, пока не завершит выполнение текущего обработчика. А выполнение текущего обработчика заблокировано.

Заканчивается это крашем процесса:

```elixir-iex
** (exit) exited in: GenServer.call(#PID<0.113.0>, :some, 5000)
    ** (EXIT) time out
    (elixir 1.11.3) lib/gen_server.ex:1027: GenServer.call/3
```

Срабатывает дефолтный таймаут в 5 секунд на GenServer.call. Но если вдруг вы указали таймаут `:infinity`, то процесс заблокируется навсегда.

Блокировка может быть более сложной, через цепочку вызовов, в которой участвуют несколько процессов. Например, процесс А делает call на процесс Б, а процесс Б делает call на процесс А -- результат такой же.

TODO: в простых случаях компилятор определяет такой deadlock. Показать пример.

Избежать этой проблемы не сложно если понимать, как работает GenServer и следить за тем, что вы делаете в обработчиках.


## Переполнение почтового ящика

Важная особенность BEAM в том, что нет никакого лимита на количество сообщений в почтовом ящике процесса. Это значит, что очередь сообщений может расти до тех пор, пока не исчерпает всю свободную память. И тогда операционная система (Out-Of-Memory Killer) аварийно завершает весь узел BEAM. Это одно из немногих слабых мест в BEAM, где ошибка в одном процессе может обрушить всю систему.

Есть две причины для роста очереди:
- нет catch-all шаблона в receive, и процесс забирает не все сообщения;
- сообщения поступают быстрее, чем процесс успевает их обрабатывать.

Выявить такие ситуации при тестировании сложно. Тем более, что рост очередей может быть очень медленным. Бывает, проходят многие часы, дни и недели прежде, чем проблема становится заметной.

Основные способы борьбы с этой проблемой:
- сбор метрик и мониторинг;
- нагрузочное тестирование.

Однако это большие и сложные темы, и я не буду их разбирать в рамках данного курса.

Существуют библиотеки, реализующие очередь сообщений с лимитом. Например, библиотека [PO Box](https://github.com/ferd/pobox).
