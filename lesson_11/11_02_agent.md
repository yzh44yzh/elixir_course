# Agent

[Agent](https://hexdocs.pm/elixir/1.12/Agent.html) -- это процесс, который хранит в своей памяти какую-то информацию, которая нужна другим процессам. 

Например, у нас есть чат-сервер, в котором есть список пользователей, находящихся онлайн (подключенных к серверу) в данный момент. 

Эта информация имеет три особенности: 
- она должна храниться столько, сколько живет вся система;
- она нужна многим процессам;
- она постоянно меняется.

В BEAM системах такого рода информацию хранят специальные процессы -- Agent и GenServer. Информация хранится в одном месте и не дублируется, так её проще обновлять. Информация живет столько, сколько живет процесс-владелец. Другие процессы запрашивают информацию у владельца через механизм обмена сообщениями.


## Простой пример

Посмотрим, как это работает. 

Мы запускаем Agent и передаём ему функцию, которая должна сформировать начальное состояние. В данном случае это пустой список:
  
```elixir
{:ok, agent_pid} = Agent.start(fn () -> [] end)
```

Затем мы обновляем состояние агента, передавая ему функцию, которая принимает текущее состояние и возвращает новое. Агент выполняет эту функцию в своём процессе:

```elixir
Agent.update(agent_pid, fn (online_users) -> ["Bob" | online_users] end)
Agent.update(agent_pid, fn (online_users) -> ["Kate" | online_users] end)
```

Мы можем запросить текущее состояние (или его часть), снова передав агенту функцию, которую он выполнит в своём процессе:

```elixir
Agent.get(agent_pid, fn (online_users) -> online_users end)
```

Обновление списка пользователей удобнее обернуть в некое АПИ:

```elixir
add_user = fn(name) ->
  Agent.update(agent_pid, fn (online_users) -> [name | online_users] end)
end

add_user.("John")
```

Запрос списка пользователей тоже удобнее обернуть в АПИ:

```elixir
get_users = fn() ->
  Agent.get(agent_pid, fn (online_users) -> online_users end)
end

get_users.()
```

И дальше с этим можно работать:

```elixir
add_user.("Helen")
add_user.("Bill")
get_users.()
```


## Агент, обернутый в модуль

TODO session_manager.exs

Недостаток агента в том, что сторонний код имеет полный доступ к его состоянию. Это легко исправить, если обернуть агент в модуль, и реализовать доступ через АПИ модуля.

Рассмотрим этот подход на примере.

Допустим, наш чат-сервер представляет собой кластер из четырех узлов. Мы хотим распределить онлайн пользователей равномерно между узлами и для этого применяем шардинг -- делим всех пользователей на 48 групп (шардов). С помощью некой хеширующей функции мы для каждого пользователя вычисляем, к какому шарду он относится. А затем подключаем пользователя к нужному узлу кластера.

Для этого нам нужно знать, за какой диапазон шард отвечает каждый узел. Эту информацию можно хранить в списке:

```elixir
[
  { 0, 11, "Node-1"},
  {12, 23, "Node-2"},
  {24, 35, "Node-3"},
  {36, 47, "Node-4"}
]
```

А список мы будем хранить в агенте. Мы помним, что процесс можно зарегистрировать под определенным именем, чтобы обращаться к нему по имени, а не по pid. Агента тоже можно зарегистрировать таким образом.

```elixir
state = [
  { 0, 11, "Node-1"},
  {12, 23, "Node-2"},
  {24, 35, "Node-3"},
  {36, 47, "Node-4"}
]
Agent.start(fn () -> state end, [name: :sharding_info])
```

Обернем агента в модуль, реализуем АПИ для доступа к информации о шардах и посмотрим, как это работает:

```elixir-iex
iex(1)> c "lib/shard_manager.exs"
iex(2)> alias ShardManager, as: SM
iex(3)> SM.start
:ok
iex(4)> SM.find_node(1)
{:ok, "Node-1"}
iex(5)> SM.find_node(10)
{:ok, "Node-1"}
iex(6)> SM.find_node(12)
{:ok, "Node-2"}
iex(7)> SM.find_node(30)
{:ok, "Node-3"}
iex(8)> SM.find_node(300)
{:error, :not_found}
```


## Усложняем АПИ

Иногда бывает нужно перераспределить шарды между узлами (выполнить решардинг). Обычно это бывает, когда у нас меняется количество узлов в кластере.

Добавим в наш модуль такое АПИ:

```elixir-iex
> r SM
> nodes = ["Node-1", "Node-2", "Node-3", "Node-4", "Node-5"]
> SM.reshard(nodes, 48) 
[
  {36, 44, "Node-5"},
  {27, 35, "Node-4"},
  {18, 26, "Node-3"},
  {9, 17, "Node-2"},
  {0, 8, "Node-1"}
]
> SA.find_node(30)
{:ok, "Node-4"}
```


## Взаимодействие двух агентов

Теперь, когда у нас есть два агента, давайте организуем взаимодействие между ними.

Но сначала первый агент, который хранит список онлайн пользователей, мы тоже обернем в модуль. И сделаем так, чтобы каждый пользователь был привязан к определенному шарду и узлу.

```elixir
def add_user(username) do
  shard = :erlang.phash2(username, 48)
  {:ok, node} = ShardManager.find_node(shard)
  Agent.update(:online_users, fn(users) -> [{username, shard, node} | users] end)
end
```

Функция `:erlang.phash2/2` позволяет получить хеш от любого значения в виде целого числа в заданом диапазоне. 

Нужно запустить оба агента прежде, чем вызывать их АПИ:
  
```elixir
> c "lib/agents_interation.exs"
> ShardManager.start
> SessionManager.start
> SessionManager.add_user("Helen")
> SessionManager.add_user("Bob")
> SessionManager.add_user("Kate")
> O.get_users()
[{"Kate", 17, "Node-2"}, {"Bob", 33, "Node-3"}, {"Helen", 13, "Node-2"}]
```

На этом месте опытные разработчики заметят, что если теперь выполнить решардинг, то данные об узлах в списке пользователей станут невалидными. Это верно. Решардинг часто бывает сложной задачей. Это тема для курса "Elixir Expert", а не "Elixir Junior" :)
