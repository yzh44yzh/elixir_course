# Supervisor

## Зачем нужен супервизор

Мы знаем, что одни процессы могут отслеживать падение других процессов через механизмы link и monitor. Логичный шаг -- поручить части процессов в системе заниматься именно этим. 

И таким образом, все процессы поделятся на две категории:
- worker -- процесс, выполняющий всю полезную работу;
- supervisor -- процесс обрабатывающий падение worker.

На самом деле супервизор не просто занимается падениями процессов, а обеспечивает их полный жизненный цикл:
- Start -- запуск;
- Restart -- перезапуск;
- Shutdown -- завершение, штатное и аварийное.


## Start

Супервизор на старте получает **child specification**. Это структура данных, которая декларативно описывает, какие дочерние процессы должны быть запущены и каким именно образом. Выглядит она так:

```
[
  %{
    id: "child_1",
    start: {PathFinder, start_link, []}, #MFA
    restart: :permanent,
    shutdown: 5000,
    type: :worker
  },
  %{
    id: "child_2",
    start: {Map_Reduce, start, [processes_tree]}
  },
  %{
    id: "child_3",
    start: {ShardManager, start, []}
  }
]
```

Здесь мы указываем 3 дочерних процесса и описываем их в виде Map с определенным набором ключей:

**:id** -- идентификатор процесса. Мы привыкли идентифицировать процессы по pid, но в данном случае это не подходит, потому что процесс может несколько раз запускаться и завершаться, при этом pid будет меняться. Поэтому супервизор использует отдельный идентификатор, который в каждый конкретный момент времени указывает на один конкретный процесс, но в разное время это могут быть разные процессы.

**:start** -- кортеж `{Module, function, args}`, который описывает, как запустить процесс. (Такой кортеж обычно называют MFA).

**:restart** -- стратегия рестарта (будет описана ниже).

**:shutdown** -- стратегия завершения процесса (будет описана ниже).

**:type** -- тип дочернего процесса: `:worker` или `:supervisor`.

Первые два ключа обязательны, для остальных супервизор подставит значения по-умолчанию, если они не будут указаны явно.

Получив child specification, супервизор запускает дочерние процессы по очереди. Для каждого элемента списка супервизор вызывает MFA и блокируется, пока не получит ответ, затем переходит к следующему элементу. В случае с GenServer супервизор блокируется, пока не завершится init. Поэтому важно, чтобы init не выполнялся слишком долго.


## Restart

Есть две настройки, которые определяют, как супервизор рестартует процессы. Это ключ `:restart` в child specification и ключ `:strategy` в настройках самого супервизора.

**:restart** относится к дочернему процессу и имеет 3 варианта:
- `:permanent` - процесс нужно перезапускать всегда;
- `:temporary` - процесс не нужно перезапускать;
- `:transient` - процесс нужно перезапустить, если он завершился аварийно, и не нужно перезапускать, если он завершился в штатном режиме.

Тут важно разобраться, что такое штатное и аварийное завершение.

Как мы помним, при завершении процесса отправляется сигнал `exit` всем связанным процессам. Разумеется, супервизор связывается со своими дочерними процессами, и устанавливает у себя флаг trap_exit:
```
Process.flag(:trap_exit, true)
```
так что эти сигналы попадают к нему в почтовый ящик в виде сообщений:
```
{:EXIT, #PID<0.122.0>, reason}
```

reason -- это причина завершения процесса и здесь может быть любая структура данных. 

Супервизор считает, что процесс завершился штатно, если reason:
- `:normal`
- `:shutdown`
- `{:shutdown, any}`

Любые другие значения считаются не штатным (аварийным) завершением процесса.

**:strategy** относится к супервизору и определяет, сколько дочерних процессов будет перезапущено.
- `:one_for_one` -- перезапускается только один процесс;
- `:one_for_all` -- при завершении любого процесса перезапускаются все дочерние процессы;
- `:rest_for_one` -- при завершении процесса перезапускается этот процесс и те, которые стартовали позже него.

(В Эрланге есть еще стратегия `:simple_one_for_one`, но в Эликсире её заменил динамический супервизор. Мы рассмотрим эту тему позже.)

Перезапуск порождает новый процесс с новым pid и новым начальным состоянием. Состояние старого процесса теряется.

Возможна ситуация, когда перезапуск попадает в бесконечный цикл: процесс запускается, крашится, опять запускается, опять крашится, и т.д. Для этой ситуации есть еще две настройки: `:max_restarts` и `:max_seconds`. Если количество рестартов за определенный промежуток времени превышает указанный лимит, то супервизор завершает все дочерние процессы и завершается сам. Таким образом проблема переходит на уровень выше -- к родительскому супервизору. И тот рестартует уже целую ветку процессов. 


## Shutdown

Супервизор завершает дочерние процессы в очередности противоположной их запуску. Каждому процессу супервизор отправляет сигнал `exit` с причиной `:shutdown`:
```
Process.exit(child_pid, :shutdown)
```
Затем ждет некоторое время его завершения. И переходит к следующему процессу. 

Если дочернему процессу нужно специальным образом обработать завершение, то он устанавливает флаг `:trap_exit`, и тогда у него срабатывает обработчик `terminate`. 

Если дочерний процесс не успевает завершится за отведенное время, то супервизор посылает сигнал `exit` с причиной `:kill`:
```
Process.exit(child_pid, :kill)
```
и дочерний процесс завершается сразу же, без обработчиков.

Завершив все дочерние процессы, супервизор завершается сам с причиной `:shutdown`, и сигнал об этом уходит родительскому супервизору.

Теперь вспомним про настройку `:shutdown`, которая указывается в child specification. Это число, которое определяет, сколько миллисекунд супервизор будет ждать завершения родительского процесса. По умолчанию 5000 миллисекунд.

Вместо числа можно указать значение `:brutal_kill`, и тогда супервизор сразу пошлет сигнал kill и не даст дочернему процессу обработать свое завершение.

Еще можно указать значение `:infinity`, тогда супервизор не будет посылать сигнал kill, и дочерний процесс будет завершаться столько, сколько ему нужно. Если дочерний процесс сам является супервизором, то для него по-умолчанию выставляется значение `:infinity`.

TODO картинка и код на практике:
```
sup:                               | worker:
                                   | init: Process.flag(:trap_exit, true)
Process.exit(child_pid, :shutdown) | terminate
wait 5000 ms
Process.exit(child_pid, :kill)
```

## Дерево супервизоров (Supervision Tree)

Как мы уже упоминали выше, дочерним процессом у супервизора может быть другой супервизор. Таким образом формируется дерево, где узлами являются супервизоры, а листьями рабочие процессы. Не редко такое дерево бывает глубиной 2-4 уровня.

![supervision_tree](./img/supervision_tree.png)

Дерево позволяет изолировать друг от друга разные части системы, запускать и перезапускать их независимо друг от друга.

Запуск процессов вне дерева супервизоров -- плохая практика. В этом случае никто не управляет жизненным циклом таких процессов. Падение процесса останется незамеченным и необработанным. А если процесс вдруг станет неправильно работать, то будет сложнее диагностировать и исправить эту ситуацию. 

Теперь нам нужно научиться запускать под супервизором Task, Agent и GenServer.
