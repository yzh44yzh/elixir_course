# Бинарные и текстовые протоколы

## Бинарные протоколы

Хороший сервер должен работать в пассивном режиме. То есть, он должен получать данные от клиента не в виде сообщений в почтовый ящик, а вызовом `:gen_tcp.recv/2`.

Нюанс в том, что тут нужно указать, сколько данных мы хотим прочитать. А откуда сервер может знать, сколько данных ему прислал клиент? Ну, видимо, клиент сам должен сказать, сколько данных он собирается прислать. Для этого клиент сперва посылает небольшой служебный пакет, в котором указывает размер своих данных, и затем посылает сами данные.

Например, если клиент хочет послать данные "Hello", размер которых 5 байт, то он посылает сперва `5`, затем "Hello">>. Соответственно, сервер сперва читает этот служебный пакет, и по нему определяет, сколько данных нужно прочитать дальше.

Теперь нужно решить, сколько байт должен занимать этот служебный пакет. Если это будет 1 байт, то в него нельзя упаковать число больше 255. В 2 байта можно упаковать число 65535, в 4 байта 4294967295. 1 байт, очевидно, мало. Вполне вероятно, что клиенту будет нужно послать данных больше, чем 255 байт. Заголовок в 2 байта вполне подходит. Заголовок в 4 байта иногда бывает нужен.

Итак, клиент посылает служебный пакет размером в 2 байта, где указано, сколько данных последуют за ним, а затем сами эти данные.

TODO примеры бинарных протоколов:
- protobuf, thrift
- драйвер для работы с БД (PostgreSQL, MySQL);
- клиент для работы с RabbitMQ;

TODO
term_to_binary, binary_to_term


### Работа с бинарными данными

Кодирование в бинарник:

```
iex(8)> val1 = 100
100
iex(9)> val2 = 300
300
iex(10)> <<val1 :: 16, val2 :: 16>>
<<0, 100, 1, 44>>

iex(2)> val = 255
255
iex(3)> <<val :: 16>>
<<0, 255>>
iex(4)> val = 256
256
iex(5)> <<val :: 16>>
<<1, 0>>

iex(14)> val = 1024 * 1024
1048576
iex(15)> <<val :: 16>>
<<0, 0>>
iex(16)> <<val :: 32>>
<<0, 16, 0, 0>>

iex(22)> val = :math.pow(2, 16) |> trunc 
65536
iex(23)> <<val :: 16>>
<<0, 0>>
iex(24)> <<val :: 32>>
<<0, 1, 0, 0>>
```

Декодирование из бинарника:
```
iex(13)> data = <<0, 100, 1, 44>>
<<0, 100, 1, 44>>
iex(14)> <<val1 :: 16, _ :: binary>> = data
<<0, 100, 1, 44>>
iex(15)> val1
100
iex(16)> <<_ :: 16, val2 :: 16>> = data
<<0, 100, 1, 44>>
iex(17)> val2
300
```

External Term Format
https://www.erlang.org/doc/apps/erts/erl_ext_dist.html

```
iex(5)> data = %{a: 42, b: 100, c: [1,2,3]}
%{a: 42, b: 100, c: [1, 2, 3]}
iex(6)> :erlang.term_to_binary(data)
<<131, 116, 0, 0, 0, 3, 100, 0, 1, 97, 97, 42, 100, 0, 1, 98, 97, 100, 100, 0,
  1, 99, 107, 0, 3, 1, 2, 3>>
iex(7)> :erlang.binary_to_term(v())
%{a: 42, b: 100, c: [1, 2, 3]}
```

### Заголовок пакета

```
Msg = <<"Hello">>,
Size = byte_size(Msg),
Header = <<Size:16/integer>>,

iex(1)> msg = "Hello"
iex(2)> size = byte_size(msg)
iex(3)> header = <<size::16>>
<<0, 5>>
iex(4)> header = <<size::32>>
<<0, 0, 0, 5>>
iex(5)> header <> msg
<<0, 0, 0, 5, 72, 101, 108, 108, 111>>

:gen_tcp.send(socket, header <> msg)
```

### Пассивный режим

### TCP-клиент

Использовать Telnet не получится, нужно реализовать TCP клиент.

TODO: на базе acceptor pool реализовать варианты:
- [ ] binary protocol, active:true
- [ ] binary protocol, active:false
- [ ] binary protocol, packet:2


## Текстовые протоколы

Кроме варианта со служебным заголовком, есть и другой подход. Можно читать из сокета по одному байту, пока не встретится специальный байт, символизирующий конец пакета. Это может быть нулевой байт, или символ перевода строки.

Такой вариант характерен для текстовых протоколов (SMTP, POP3, FTP).

Писать свою реализацию чтения из сокета нет необходимости, все уже реализовано в gen_tcp. Нужно только указать в настройках сокета вместо `{:packet, 2}` опцию `{:packet, :line}`.

Можно вернутся к Telnet.

TODO примеры текстовых протоколов:
- SMTP 
- POP3
- FTP
