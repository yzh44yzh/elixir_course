# UDP Socket

User Datagram Protocol

Вспомним в общих чертах, что такое UDP:
- протокол передачи коротких сообщений (Datagram);
- быстрая доставка;
- без постоянного соединения между клиентом и сервером, без состояния;
- доставка сообщения и очередность доставки не гарантируется.

Для работы с UDP используется эрланговский модуль gen_udp.
https://www.erlang.org/doc/man/gen_udp.html

Примеры UDP: 
- передача видео и звука в реальном времени (live streaming).

TODO ещё примеры

  IP 
  Internet Protocol (IP + Port)

  UDP 
  User Datagram Protocol
  - Datagram -- short msg 1.5Kb
  - no client/server, all nodes are the same
  - fast
  - no garanties (devilery, ordering)
  Live Streaming (video & audio)

  TCP 
  Transmission Control Protocol
  - Any size data. 
  - strict garanties (devilery, ordering) ack acknowledge
  - client/server roles
  - persistent connection (session)
  - handshake

  HTTP over TCP
  cowboy | ranch


## Отправка и получение данных

Давайте запустим две консоли iex (два узла) и наладим общение между ними.

На 1-м узле откроем UDP сокет на порту 2000:
```
iex(1)> {ok, socket} = :gen_udp.open(2000, [:binary, {:active, true}])
{:ok, #Port<0.6>}
```

Вызываем `:gen_udp.open/2`, передаем номер порта и список опций. Список всех возможных опций довольно большой, но нас интересуют две из них:

**:binary** -- сокет открыт в бинарном режиме. Как вариант, сокет можно открыть в текстовом режиме, указав опцию list. Разница в том, как мы интерпретируем данные, полученные из сокета -- как поток байт, или как текст.

**{:active, true}** -- сокет открыт в активном режиме, значит данные, приходящие в сокет, будут посылаться в виде сообщений в почтовый ящик потока, владельца сокета. Подробнее об этом ниже.

На 2-м узле откроем UDP сокет на порту 2001:

```
iex(1)> {ok, socket} = :gen_udp.open(2001, [:binary, {:active, true}])
{:ok, #Port<0.6>}
```

И пошлем сообщение с 1-го узла на 2-й:

```
iex(2)> :gen_udp.send(socket, {127,0,0,1}, 2001, "Hello from 2000")
:ok
```

Вызываем `:gen_udp.send/4`, передаем сокет, адрес и порт получателя, и само сообщение.

На 2-й ноде убедимся, что сообщение пришло:

```
iex(2)> flush()
{:udp, #Port<0.6>, {127, 0, 0, 1}, 2000, "Hello from 2000"}
:ok
```

Сообщение приходит в виде кортежа `{:udp, socket, sender_address, sender_port, payload}`.

Пошлем сообщение со 2-го узла на 1-й:

```
iex(3)> :gen_udp.send(socket, {127,0,0,1}, 2000, "Hello from 2001")
:ok
```

На 2-м узле убедимся, что сообщение пришло:

```
iex(4)> flush()
{:udp, #Port<0.6>, {127, 0, 0, 1}, 2001, "Hello from 2001"}
:ok
```

## Активный и пассивный режим сокета

Сокет имеет важную настройку: режим работы с входящими данными. Это может быть либо активный режим `{:active, true}`, либо пассивный режим `{:active, false}`.

В активном режиме процесс получает входящие пакеты в виде сообщений в своем почтовом ящике. И их можно получить и обработать вызовом `receive`, как любые другие сообщения.

Активный режим прост в использовании, но опасен тем, что клиент может переполнить почтовый ящик процесса. Поэтому рекомендуется пассивный режим.

В пассивном режиме данные нужно забрать вызовами `:gen_udp.recv/2`. Если в сокете есть эти данные, то вызов `recv` сразу возвращает их. Если данных нет, то вызов блокируется, пока они не придум. Можно указать timeout, чтобы не блокировать процесс надолго.

На первом узле откроем ещё один сокет в пассивном режиме. Мы используем другой порт чтобы открыть другой сокет:

```
iex(5)> {ok, socket} = :gen_udp.open(3000, [:binary, {:active, false}])
{:ok, #Port<0.7>}
```

Со второго узла отправим сообщение:

```
iex(5)> :gen_udp.send(socket, {127,0,0,1}, 3000, "Hello again from 2001")
:ok
```

На первом узле получим его:

```
iex(7)> :gen_udp.recv(socket, 0)
{:ok, {{127, 0, 0, 1}, 2001, "Hello again from 2001"}}
```

Второй аргумент -- сколько байт мы хотим прочитать из сокета. Это важно для TCP-сокета. UDP-сокет игнорирует этот аргумент и отдаёт все данные, что есть.

Теперь сделаем наоборот, сперва вызовем `recv` на первом узел, и увимим, что он заблокировался. Затем отправим данные со второго узла, и увимим, что они пришли на первый узел.

И попробуем вызов `recv` с указанием timeout:

```
iex(9)> :gen_udp.recv(socket, 0, 5000)
{:error, :timeout}
```

Как видим, пользоваться UDP-сокетом довольно просто.


