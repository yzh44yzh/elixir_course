# Связь между процессами 

Одна из главных фич beam -- устойчивость к ошибкам (fault tolerance). Считается, что BEAM может легко переживать ошибки в коде и в данных, аппаратные сбои, сбои в сети и продолжать обслуживать клиентов.

Это не значит, что любой код на эликсир "из коробки" обладает такими свойствами. Об этом должен позаботиться программист. BEAM только дает средства, которыми программист может обеспечить устойчивость. Давайте посмотрим, что это за средства.

Устойчивость к ошибкам построена на способности процессов наблюдать друг за другом. Для этого есть два способа -- **связь (link)** и **мониторинг (monitor)**.

Два процесса можно связать друг с другом так, что при падении одного, второй получит специальное сообщение и тоже упадет. Можно связать группу процессов так, что при падении одного из них, упадет вся группа. 

Предполагается, что процессы зависят друг от друга в своей работе. Отсутствие одного процесса приводит к нештатной ситуации, в которой остальные не могут выполнять полезных действий. Они только усугубляют и распространяют проблемы. Так что лучше остановить и рестартовать всю группу.

Информация о падении передается специальным **системным сообщением** (**сигналом**). Системные сообщения не попадают в почтовый ящик, и их нельзя обработать обычным способом. Вместо этого они завершают процесс, который их получил, и распространяются дальше по имеющимся связям.


## link и spawn_link

Вызов [process.link/1](https://hexdocs.pm/elixir/1.12/Process.html#link/1) создает связь между текущим процессом и заданным. Связь двусторонняя. Чтобы связать несколько процессов, нужно сделать несколько вызовов **link**. Если процессы уже связаны, то вызов **link** не оказывает никакого эффекта.

Вызов [process.unlink/1](https://hexdocs.pm/elixir/1.12/Process.html#unlink/1) разрывает связь.

Обычно запуск нового процесса и установление связи с ним выполняют, как одно атомарное действие. Для этого используется функция [Kernel.spawn_link/3](https://hexdocs.pm/elixir/1.12/Kernel.html#spawn_link/3). Если это делать двумя последовательными вызовами **spawn** и **link**, то процесс может завершиться до вызова **link**.

Запустим 5 процессов, но сделаем, чтобы один из них аварийно завершался. Пусть это будет 3-й процесс, как раз в середине всей группы процессов:

```elixir-iex
iex(3) c "lib/link.exs"
[LinkExample]
iex(4) alias LinkExample, as: L
iex(5)> L.run_and_exit(5)
Process id:1 pid:#PID<0.162.0> started
Process id:3 pid:#PID<0.164.0> started
Process id:2 pid:#PID<0.163.0> started
Process id:4 pid:#PID<0.165.0> started
Process id:5 pid:#PID<0.166.0> started
[#PID<0.162.0>, #PID<0.163.0>, #PID<0.164.0>, #PID<0.165.0>, #PID<0.166.0>]
Process id:3 exits
Process id:2 pid:#PID<0.163.0> stopped
Process id:1 pid:#PID<0.162.0> stopped
Process id:5 pid:#PID<0.166.0> stopped
Process id:4 pid:#PID<0.165.0> stopped
```

Мы видим, что процессы стартовали. Один из них аварийно завершился, а остальные завершились нормально.

Теперь используем для запуска процессов spawn_link вместо spawn:

```elixir-iex
iex(5)> L.run_and_exit(5)
Process id:0 pid:#PID<0.130.0> started
Process id:1 pid:#PID<0.131.0> started
Process id:2 pid:#PID<0.132.0> started
Process id:3 pid:#PID<0.133.0> started
Process id:4 pid:#PID<0.134.0> started
Process id:5 pid:#PID<0.135.0> started
[#PID<0.130.0>, #PID<0.131.0>, #PID<0.132.0>, #PID<0.133.0>, #PID<0.134.0>,
 #PID<0.135.0>]
Process id:3 exits
** (EXIT from #PID<0.107.0>) shell process exited with reason: :some_reason
```

Опять мы видим, что процессы стартовали, и один из них аварийно завершился. Но теперь мы не видим сообщений от остальных процессов, что они завершились нормально. Потому что все они завершились аварийно и не выполнили функцию `start_and_exit/1` до конца.

Процесс iex-консоли также завершился, потому что все процессы были связаны с ним:

```elixir-iex
iex(11)> self()
#PID<0.137.0>
iex(12)> L.run_and_exit(5)
...
iex(1)> self()
#PID<0.190.0>
```

Но iex-консоль рестартовала в новом процессе, что позволило нам работать дальше.


## Системные процессы

То, что процессы падают не по одному, а все вместе, не похоже на хороший способ построить систему, устойчивую к ошибкам. Одних связей между процессами мало, нужно еще разделение ролей.

Есть рабочие процессы, которые делают полезную работу. И есть системные процессы, которые следят за состоянием рабочих процессов.

Чтобы сделать процесс системным, нужно установить в его метаданных специальный флаг **trap_exit**:

```elixir-ix
iex(4)> Process.flag(:trap_exit, true)
```

После чего сигналы, которые получает процесс, превращаются в обычные сообщения и попадают в почтовый ящик. Таким образом системный процесс может обработать падение рабочего процесса.

Запустим еще раз нашу группу процессов:

```elixir-iex
iex(5)> T.run_and_exit(5)
Process id:2 pid:#PID<0.121.0> started
Process id:1 pid:#PID<0.120.0> started
Process id:3 pid:#PID<0.122.0> started
Process id:4 pid:#PID<0.123.0> started
Process id:5 pid:#PID<0.124.0> started
[#PID<0.120.0>, #PID<0.121.0>, #PID<0.122.0>, #PID<0.123.0>, #PID<0.124.0>]
Process id:3 exits
Process id:1 pid:#PID<0.120.0> stopped
Process id:5 pid:#PID<0.124.0> stopped
Process id:2 pid:#PID<0.121.0> stopped
Process id:4 pid:#PID<0.123.0> stopped
```

Теперь мы видим, что упал только один из них, остальные успешно завершились. Сигнал об аварийном завершении был перехвачен консолью и не распространился на остальные процессы.

Посмотрим в почтовый ящик:

```elixir-iex
iex(6)> flush()
{:EXIT, #PID<0.122.0>, :some_reason}
{:EXIT, #PID<0.120.0>, :normal}
{:EXIT, #PID<0.124.0>, :normal}
{:EXIT, #PID<0.121.0>, :normal}
{:EXIT, #PID<0.123.0>, :normal}
```

Здесь находятся 5 сигналов о завершении 5 процессов. 

Каждый сигнал -- это кортеж из 3-х элементов. На первой позиции атом 'EXIT', на второй -- Pid рабочего процесса, на третьей позиции -- причина завершения процесса. Мы видим, что 4 процесса завершились с причиной `:normal`, и один процесс с причиной `:some_reason`.


## exit

Процесс может завершиться двумя способами: нормально или аварийно. В первом случае процесс просто выполнил до конца ту функцию, с которой он стартовал. Во втором случае произошло исключение.

Кроме этого, процесс можно принудительно завершить вызовом функции [Process.exit/2](https://hexdocs.pm/elixir/1.12/Process.html#exit/2)

**exit** завершает указанный процесс с заданной причиной:

```
iex(5)> Process.exit(self(), :normal)

Interactive Elixir (1.11.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
nil
iex(2)> self()
#PID<0.115.0>
iex(3)> Process.exit(self(), :some_error)
** (EXIT from #PID<0.115.0>) shell process exited with reason: :some_error

Interactive Elixir (1.11.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> self()
#PID<0.119.0>
```

Как причину можно указать любую структуру данных. Обычно для этого используют атомы. Два атома имеют особый смысл:
- `:normal` обозначает нормальное завершение процесса;
- `:kill` обозначает завершение процесса, которое нельзя перехватить в системном процессе.

Таким образом можно эмулировать и нормальное, и аварийное завершение процесса.


## Варианты событий при завершении процесса

Связи между процессами, системные процессы и разные способы завершения образуют довольно сложную систему. Попробуем с ней разобраться.

Возьмем 5 связанных процессов:

![link_exit_1](./img/link_exit_1.png)

Здесь три рабочих процесса (W1, W2, W3) и два системных процесса (S4, S5). Красными линиями показаны связи.

Рассмотрим, что будет происходить в системе при завершении процесса W2 с разными причинами.


### Нормальное завершение процесса

![link_exit_2](./img/link_exit_2.png)

Процесс W2 завершается нормально. Сигнал доходит до процесса W1, но игнорируется. W1 продолжает работать, хотя теперь он ни с кем не связан.

Сигнал доходит до процесса S4, превращается в сообщение `{'EXIT', <0.2.0>, normal}` и попадает в почтовый ящик S4. Дальше сигнал не распространяется.


### Аварийное завершение процесса

![link_exit_3](./img/link_exit_3.png)

Процесс W2 завершается аварийно с некой причиной `reason`. Сигнал доходит до процесса W1, и W1 тоже завершается аварийно с той же причиной.

Сигнал доходит до процесса S4, превращается в сообщение `{'EXIT', <0.2.0>, Reason}`, и попадает в почтовый ящик S4. Дальше сигнал не распространяется.


### Завершение процесса с причиной kill

Здесь ситуация сложнее. Создатели эрланг предусмотрели способ аварийно завершить системный процесс на случай, если большая часть системы придет в неконсистентное состояние. Этот способ -- завершение процесса с причиной `:kill`.

Сигнал с причиной `:kill` не превращается в сообщение, не перехватывается системным процессом, а заставляет процесс завершиться с причиной `:killed`. Тут важно, что меняется причина с `:kill` на `:killed`, иначе такой сигнал невозможно было бы остановить, и он завершил бы все процессы. Ну а `:killed` перехватывается системными процессами обычным способом.

![link_exit_4](./img/link_exit_4.png)

Процесс W2 завершается с причиной `:kill`. Сигнал доходит до процесса W1, и W1 завершается с причиной `:killed`.  Сигнал доходит до процесса S4, и S4 завершается с причиной `:killed`.

Сигнал распространяется дальше. Доходит до W3, и W3 завершается с причиной `:killed`.  Наконец, сигнал доходит до S5, превращается в сообщение `{'EXIT', <0.4.0>, :killed}` и попадает в почтовый ящик S5.
