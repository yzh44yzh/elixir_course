# Работа с процессами на низком уровне

Эффективная поддержка многопоточности -- одна из главных фишек виртуальной машины BEAM. Она же является базой для других её свойств: масштабируемости, распределенности, устойчивости к ошибкам.

## Процессы и потоки

Прежде, чем мы начнем погружаться в BEAM, уточним терминологию, иначе мы рискуем запутаться в понятиях "процесс" и "поток".

Когда мы говорим об операционной системе (не о BEAM), то нужно различать три сущности: процесс (process), поток (thread) и зеленый поток (green thread).

**Процесс** является основой многопоточности. Это довольно "тяжелая" сущность в том смысле, что с процессом связано много разных ресурсов: 
- адресное пространство, 
- контекст (код, стек, состояние регистров), 
- файловые дескрипторы (в т.ч. стандартный ввод-вывод), 
- сокеты, 
- пользовательские права. 

Создание процесса -- это относительно дорогая операция. И количество процессов, которые можно создать, ограничено.

**Поток** (он еще может называться "нить выполнения", thread) -- это "легковесная" сущность. С ним связано горазо меньше ресурсов, и его создание намного дешевле. Обычно в рамках одного процесса могут существовать несколько потоков, которые разделяют между собой ресурсы процесса.

Процессы изолированы друг от друга и взаимодействуют через механизмы, предоставляемые ОС. Потоки не изолированы и взаимодействуют через общую память.

Еще есть **зеленые потоки** (grean thread). Они отличаются тем, что реализованы на уровне библиотеки или виртуальной машины, и работают в пользовательском пространстве. ОС про них не знает и не управляет ими. Они еще более "легковестны", так как создание и управление ими не требует системных вызовов. У них, однако, есть недостатки: если один из потоков делает системный вызов, например, для работы со стандартным вводом-выводом, то это блокирует все потоки в рамках одного процесса. Аварийное завершение потока приводит к завершению родительского процесса и всех потоков в нем.

Теперь, если мы говорим про BEAM, то по сути имеем дело с зелеными потоками. Однако реализация потоков в BEAM лишена перечисленных выше недостатков. 

В документации Эликсира и Эрланга *потоки* BEAM принято называть *процессами*. Что несколько противоречит терминологии на уровне ОС. Дальше в курсе я тоже буду называть их *процессами*.


## Легковесные процессы BEAM

BEAM имеет собственную реализацию многопоточности поверх процессов операционной системы. На одном системном процессе могут работать сотни и тысячи процессов BEAM. Виртуальная машина управляет ими независимо от операционной системы.

Каждый процесс имеет свою память -- стек (stack) и кучу (heap) -- и может владеть некоторыми ресурсами, например, сокетами. Процессы изолированы, не имеют общей памяти и общих ресурсов. (Это не совсем точно, в некоторых случаях общая память все-таки имеется). 

Процессы BEAM не блокируют друг друга (но разработчик может явно реализовать блокировку). И аварийное завершение (crash) процесса не приводит к завершению других процессов (но разработчик может явно указать, что это должно происходить).

Процессы BEAM легковесные. Это значит, что они:
- быстро стартуют и завершаются;
- быстро переключаются;
- потребляют мало памяти.

Новый процесс создается и стартует за 3-5 микросекунд. На старте он получает 2,5Кб памяти (стек, куча и служебная информация о процессе).

Виртуальная машина имеет лимит на число процессов, по умолчанию это 262,144 (2^18). Лимит можно увеличить до 134,217,727 (2^27). Но вряд ли кому-то захочется создать 134 млн процессов на одной ноде, тем более, что для этого понадобится 336Гб оперативной памяти :)

Легковесность процессов качественно меняет архитектурные подходы. В отличие от процессов ОС, процессы BEAM не являются ограниченым ресурсом. Можно легко выделить отдельный процесс на обслуживание каждого клиенского соединения и позволить клиенту занимать этот процесс сколь угодно долго.

Поэтому типичная область применения BEAM -- это сервера, которые должны обслуживать большое количество клиентов. Особенно если соединения с клиентами являются долгоживущими.


## Создание процесса

Для создания нового процесса используется функция [spawn](https://hexdocs.pm/elixir/1.12/Kernel.html#spawn/1).

```elixir-iex
iex(1)> spawn(fn () -> 42 end)
#PID<0.109.0>

iex(3)> spawn(fn () -> IO.puts("Hello from #{inspect self()}") end)
Hello from #PID<0.114.0>
#PID<0.114.0>

iex(4)> self()
#PID<0.107.0>

iex(5)> spawn(IO, :puts, ["Hello"])
Hello
#PID<0.112.0>
```

Функция `spawn/1` принимает анонимную функцию, `spawn/3` принимает имя модуля, имя функции и список аргументов. spawn стартует новый процесс, который начинает выполнять переданную функцию. Когда функция завершается, процесс завершается вместе с ней. 

В варианте `spawn/1` сложнее передать аргументы, приходится использовать замыкание. Поэтому вариант `spawn/3` бывает удобнее.

```elixir-iex
> spawn(IO, :puts, ["hello from #{inspect self()}"])
hello from #PID<0.111.0>
#PID<0.120.0>
```
Тут аргумент сперва вычисляется в процессе консоли, а потом передаётся в spawn.

spawn возвращает **Pid** -- идентификатор процесса (process identifier). Зная Pid, можно посылать процессу сообщения и получать информацию о нем.

Давайте попробуем запустить несколько процессов:

```elixir-iex
iex(1)> c("lib/processes.exs")
[ProcessesExample]
iex(2)> alias ProcessesExample, as: P
iex(3)> P.run_processes(10)
```

Мы видим, что первый IO.puts чаще всего срабатывает по возрастанию id. Но не всегда, если будем запускать это несколько раз, то можем увидить, что порядок нарушается. Второй IO.puts срабатывает в случайном порядке, потому что у каждого процесса своя случайная пауза.


## Отправка сообщений

Процессы BEAM взаимодействуют через отправку сообщений. Для этого используется функция [Kernel.send/2](https://hexdocs.pm/elixir/1.12/Kernel.html#send/2).

Первым аргументом мы передаем получателя сообщения. Это может быть Pid или имя, под которым зарегистрирован получатель. Второй аргумент -- сообщение. Это может быть любая структура данных. Сообщения копируется из памяти отправителя в специальную область в памяти получателя, которая называется "почтовый ящик" (mailbox).

```elixir-iex
iex(23)> send(self(), :hello)
:hello
iex(24)> flush()
:hello
:ok

iex(25)> send(self(), :hello1)
:hello1
iex(26)> send(self(), :hello2)
:hello2
iex(31)> send(self(), {:hello3, 42})
{:hello3, 42}
iex(32)> send(self(), ["message", :can, {'be', "any"}, :data])
["message", :can, {'be', "any"}, :data]

iex(33)> flush()
:hello1
:hello2
{:hello3, 42}
["message", :can, {'be', "any"}, :data]
:ok
```

Здесь процесс iex отправляет сообщение самому себе. Затем с помощью функции `flush` мы проверяем содержимое почтового ящика процесса iex.

Отправка сообщения выполняется асинхронно. Отправитель не блокируется и не ждет ответа, а продолжает выполнение своего кода. 

При попытке отправить сообщение несуществующему процессу, сообщение просто игнорируется. Ошибки при этом не происходит.
