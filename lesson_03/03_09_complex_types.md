# Сложные типы (Complex types)

## IO List

Рекурсивный тип данных, который состоит из:
- byte (число в диапазоне 0-255)
- String.t (бинарная строка)
- IO List (включает сам себя)

Такой тип поддерживается во всех операциях ввода-вывода и позволяет избежать дорогостоящей конкатенации строк.

Не эффективно:

```elixir-iex
iex(8)> header = "<html><body>"
"<html><body>"
iex(9)> footer = "</body></html>"
"</body></html>"
iex(10)> name = "Bob"
"Bob"
iex(11)> body = "hello " <> name <> "!"
"hello Bob!"
iex(12)> page = header <> body <> footer
iex(15)> IO.puts page
<html><body>hello Bob!</body></html>
```

Здесь много операций по копированию строк из одной области памяти в другую, чтобы в итоге результат разместился в одной непрерывной области памяти.

Эффективно:

```elixir-iex
iex(8)> header = "<html><body>"
"<html><body>"
iex(9)> footer = "</body></html>"
"</body></html>"
iex(10)> name = "Bob"
"Bob"
iex(13)> body_io = ["hello ", name, "!"]
["hello ", "Bob", "!"]
iex(14)> page_io = [header, body_io, footer]
["<html><body>", ["hello ", "Bob", "!"], "</body></html>"]
iex(16)> IO.puts page_io
<html><body>hello Bob!</body></html>
:ok
```

Здесь нет копирования, а результат представляет собой дерево из ссылок на разные области памяти.

## Keyword List

Легаси со времен, когда BEAM не поддерживала map.

Список кортежей из двух элементов, где первых элемент -- atom() -- ключ, а второй элемент -- значение.

Активно используются до сих пор, хотя вроде бы незачем.

Сложившаяся традиция:
options -- настройки
Много функций в стандартной библиотеке принимают список options в виде keyword list.
TODO: например.

Например функция `IO.inspect/2`, которую можно использовать для отладочной печати.
Суть её работы в том, чтобы принять значение и распечатать в консоль.
Функция позволяет управлять своим поведением через "опции" которые передаются
через последний аргумент, являющийся keyword list`ом:

```elixir-iex
iex(1)> h IO.inspect
# => @spec inspect(item, keyword()) :: ...

iex(2)> IO.inspect([100, 200, 300])
[100, 200, 300]

iex(3)> IO.inspect([100, 200, 300], [width: 3])
[100,
 200,
 300]

```
Такой подход стал настолько широко использоваться что специально для удобства
ввели синтаксический сахар в виде сокращенного синтаксиса, позволяя явно не
указывать скобки для keyword list-а:
```elixir-iex
iex(4)> IO.inspect([100, 200, 300], width: 3, limit: 1)
[100,
 ...]
```
Визуально кажется, что здесь используется varargs(передача переменного количества
аргументов) Но на самом деле Эликсир не поддерживает такой вид передачи и на
деле просто ключи оборачиваются в keyword-список.
Т.е. такой вид полностью аналогичен этому:
```elixir-iex
iex(5)> IO.inspect([100, 200, 300], [width: 3, limit: 1])
[100,
 ...]
```
Таким образом, когда функция принимает последним аргументом keyword list
то можно обеспечить передачу переменного числа "опций" как бы эмулируя varargs
Как это и реализовано в `IO.inspect/2` и во множестве других фун-й из stdlib.
Главное при этом указать значение по умолчанию - пустой список `[]`.

```elixir
def my_fun(arg1, arg2, opts \\ []) do
  ...
end
```

TODO примеры

[{:a, 42}, {:b, 50}]
[a: 42, b: 50]

Есть стандартный модуль Keyword с множеством полезных функций. Например
фунция получения значения по ключу:
```elixir-iex
iex(1) days = [monday: 1, tuesday: 2, wednesday: 3]
[monday: 1, tuesday: 2, wednesday: 3]

iex(2)> Keyword.get(days, :monday)
1
iex(3)> Keyword.get(days, :wednesday)
3
iex(4)> Keyword.get(days, :noday)
nil
```

Так же можно обращаться к ключу через `[]` - (синтаксис как у Map)
```
iex(5)> days[:wednesday]
3
iex(6)> days[:noday]
nil
```
Здесь синтаксис как буд-то обращается к Map. но стоит чётко понимать, что на
деле это обычный список с кортежами.
А значит время поиска ключа в подобных keyword списках O(n).

в отличие от map сохраняют порядок ключей
и можно хранить несколько пар с одинаковыми ключами

## Range

TODO

1..10
a in range
iterate over range

Build on top of map.

## Sigil

TODO

## Date, Time, DateTime

TODO
