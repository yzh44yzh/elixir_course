# Что такое монада?

В 7-м уроке мы пытались ответить на вопрос "что такое функциональное программирование?". Мы говорили, что есть элементы ФП, такие как иммутабельность, рекурсия, функции высшего порядка, сопоставление с образцом и др. И функциональное программирование -- это то, что состоит **в основном** из этих элементов.

Теперь мы попробуем копнуть глубже, и разобраться, что такое **монада**. Есть шутка, что каждый новичок, приходящий в Хаскель, обязательно придумывает своё объяснение монад. Таких объяснений существует действительно много. И часто они слишком абстрактны, не дают понимания, какая от всего этого практическая польза.

Поэтому мы начали не с теории, а с практики. Мы уже применили монады и операции над ними, решили с их помощью прикладную задачу. После этого проще понять теорию.


## Примеры монад

Монада -- это значение, обернутое в некоторый полезный контекст. Например:

```elixir
{:ok, book} = BS.Book.get_book(author, title)
```

Здесь значение `book` обернуто в контекст `{:ok, book}`, и этот контекст несет информацию о том, что получен успешный результат.

```elixir
{:error, {:book_not_found, title}} = BS.Book.get_book(author, title)
```

Здесь значение `{:book_not_found, title}` обёрнуто в контекст `{:error, ...}`, и этот контекст несет информацию о том, что получена ошибка.

Это монада **Result**, которая описывается типом:

```elixir
{:ok, successful_value} | {:error, error_value}
```

Это одна из самых популярных монад, она есть практически во всех ФП языках и во многих не ФП языках:
- Haskell `Result e t`
- OCaml `('e, 't) result`
- Rust `Result<T, E>`
- Scala `Either[E, T]`

Другая популярная монада -- **Maybe** (или **Option**, в разных языках называется по-разному). Здесь контекст несет информацию о том что значение существует или не существует:

```elixir
> m = %{a: 42}
> Map.fetch(m, :a)
{:ok, 42}
> Map.fetch(m, :b)
:error
```

Maybe описывается типом:

```elixir
{:ok, value} | :error
```

Как видим, это упрощенный Result. Здесь есть `successful_value`, но нет `error_value`, а только сам контекст `:error`.

Еще одна полезная монада -- **Future**. Здесь контекст несет информацию о том, что значения прямо сейчас нет, но оно когда-нибудь будет, когда завершится асинхронное вычисление:

```elixir
iex(5)> future_value = Task.async(fn() -> 42 end)
%Task{
  owner: #PID<0.107.0>,
  pid: #PID<0.113.0>,
  ref: #Reference<0.3496306138.1615593474.196666>
}
iex(6)> Task.await(future_value)
42
```

## Оператор bind

Вспомним тему урока -- композиция функций. Вспомним 4-е решение, где мы реализовали функцию bind:

```elixir
def bind(f1, f2) do
  fn(args) ->
    case f1.(args) do
      {:ok, res} -> f2.(res)
      {:error, reason} -> {:error, reason}
    end
  end
end
```

и применили ее для композиции функций:

```elixir
f = 
  FP.bind(&step1/1, &step2/1)
  |> FP.bind(&step2/1)
  |> FP.bind(&step3/1)
  |> FP.bind(&step4/1)
  |> FP.bind(&step5/1)

f.(state)
```

bind делает композицию двух функций, и возвращает новую функцию. И что она делает? Она принимет монаду Result, извлекает значение из контекста, и в зависимости от контекста либо вызывает следующую функцию, либо просто возвращает значение.

Мы могли бы реализовать аналогичный bind для Maybe или для Future.

Представим, что у нас есть несколько асинхронных функций, которые делают запросы в разные сервисы. Нам нужно сделать несколько запросов, получить все результаты, и сделать некий суммарный результат:

```elixir
future1 = request_service_1()
value1 = Task.await(future1)

future2 = request_service_2()
value2 = Task.await(future2)

future3 = request_service_3()
value3 = Task.await(future3)
```

Мы могли бы реализовать bind, извлекающую значение из Future, и сделать композицию функций.

Это может быть простая реализация, которая делает 3 блокировки по-очереди.

```elixir
request_service_1() >>= request_service_2() >>= request_service_3()
```

Или сложная реализация, которая видит композицию всех функций как единое целое, запускает все 3 запроса одновременно, и отдаёт результаты за время, равной одной самой долгой блокировке:

```elixir
bind_futures([
  &request_service_1/0,
  &request_service_2/0,
  &request_service_3/0
])
```


## Что общего есть у всех монад?

Польза от Result и Future очевидна. Но почему они собраны в некую общую группу с названием "монады"? Что их объединяет? 

Как мы видим, их объединяет возможность делать композицию функций с помощью bind. 

У нас получились две разные bind для Result и для Future. Но вспомним, что в Эликсир есть протоколы: Enumerable, Inspect, String.Chars и др. Они позволяют делать одинаковые операции над разными типами данных. Если бы в Эликсир существовал протокол Monad, то можно было бы реализовать один bind для всех монад. В Хаскеле это так и есть.

(В языке и стандартной библиотеке Эликсир нет монад, но есть библиотека [Monad](https://hexdocs.pm/monad/Monad.html) реализующая некоторые монады и операции над ними.


## Другие операции над монадами

Давайте обозначим простое значение `v`, а значение обернутое в монаду `M<v>`.

У нас могут быть функции:

```elixir
f1(v) :: v
f2(v) :: M<v>
f3(M<v>) :: v
f4(M<v>) :: M<v>
```

Все эти варианты нужно комбинировать между собой. 

bind работает для f2: `f2 >>= f2`.

Для f1 и f4 подходит обычный pipe: `f1 |> f1`, `f4 |> f4`.

Для f3 нужно нечто противоположное bind. Что-то, что заворачивает простое значение в монаду. В Хаскеле для этого есть оператор `return`. (Название, конечно, сбивает с толку, тут return  не имеет никакого отношения к возврату значения.)

Для монады Result это можно реализовать так:

```elixir
def to_result(val), do: {:ok, val}
```

И композиция функций выглядела бы так `f3 |> to_result |> f3`. 

Для f1 и f4 в Хаскеле предусмотрены разные операторы: `f1 . f1`, `f4 >> f4`. Но в Эликсир нам это не нужно.


## Функциональная программа -- это композиция функций

В теории любая функциональная программа сводится к цепочке функций, скомпонованых друг с другом разными способами:

```elixir
f1 >>= f2 . f3 >> f4 >>= f5 . f6
```

Цепочка представляет собой happy path, а операторы композиции скрывают все ветвления в коде. То есть, мы получаем то же самое, как если бы использовали исключения для control flow. В некотором роде эти два подхода: монады и исключения, альтернативны друг другу. 

Но не всё так просто. Если мы пойдем по пути композиции, то столкнёмся с каррированием и монадными трансформерами.


## Каррирование (Currying)

Описаные выше варианты композиции работают для функций с одним аргументом. А что, если аргументов больше?

```elixir
def not_curried_fun(a, b, c) do
  a + b + c
end

> FP.not_curried_fun(1, 2, 3)
6
```

Здесь помогает каррирование. Функцию f/3 можно представить как функцию f/1, возвращающую f/2. А функцию f/2 можно представить, как f/1, возвращающую f/1:

```elixir
def curried_fun(a) do
  fn(b) ->
    fn(c) -> a + b + c end
  end
end
```

Её можно вызывать со всеми аргументами сразу:
```elixir
iex(3)> FP.curried_fun(1).(2).(3)
6
```

Или можно вызвать с одним аргументом, и в результате получить частично-применённую функцию, где 1-й аргумент уже применился, а 2 других ещё нет:

```elixir
iex(4)> f1 = FP.curried_fun(1)        
#Function<1.15736367/1 in FP.curried_fun/1>
```

Частично-применённую функцию тоже можно вызвать со всеми оставшимися аргументами, или с одним аргументом:

```elixir
iex(5)> f1.(2).(3)
6
iex(6)> f2 = f1.(2)
#Function<3.15736367/1 in FP.curried_fun/1>
```

И в конце остается частично-применённая функция, которой не хватает одного аргумента:
```elixir
iex(7)> f2.(3)
6
```

Таким образом любую функцию можно представить как функцию от одного аргумента. В Эликсир это возможно, но совершенно непрактично. А в Хаскель это работает автоматически для любой функции.

За счёт каррирования мы можем применять все способы композиции ко всем функциям.

В качестве дополнительного материала по теме можно посмотреть [реализацию функции `curry`](https://www.toptal.com/developers/hastebin/enijabupup.kotlin) для функций любой арности.

## Монадные трансформеры

На пути композиции рано или поздно мы столкнемся с монадами, вложенными друг в друга:

```elixir
Result<Maybe<v>>
Future<Maybe<Result<v>>>
```

И тогда нам понадобятся преобразования одних монад в другие. Для этого используются монадные трансформеры.

Например, наша функция `FP.sequence/1` является монадным трансформером. Она преобразует `[ Result<Book.t, Error> ]` в `Result< [Book.t], Error>`. То есть, преобразует список над Result в Result над списком.


## Выводы

В разных ФП языках монады и композиция функций поддерживаются на разном уровне. Лучше всего они развиты в **Haskell** и **Scala**. Похуже в **OCaml** и **F#**. 

В **Elixir** поддержка монад откровенно слабая. На практике удобно пользоваться **pipe**, **pipeline**, **with** и не более того. Поэтому широко применяются исключения, с ними как-то проще. А главное, привычнее, ведь в Эликсир приходят люди из императивных языков, не знакомые с монадами.

Противоположный пример -- язык **Rust**. В нём нет исключений, а есть паника, которую нельзя перехватить. Паника всегда завершает текущий процесс, поэтому её нельзя использовать для control flow. Остаётся только один путь -- монады. И они поддерживаются в Rust на хорошем уровне.

В 80-90-х годах победило императивное программирование. Это случилось потому, что оно гораздо эффективнее использовало имеющиеся ресурсы: CPU и память. А ресурсы тогда были в дефиците.

Если бы победило функциональное программирование, то сегодня код выглядел бы совершенно иначе :smiley:

