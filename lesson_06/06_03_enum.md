# Модуль Enum

[Модуль Enum](https://hexdocs.pm/elixir/Enum.html) -- основной способ работы с коллекциями. Он содержит уже известные нам функции map, filter, reduce, и еще несколько десятков других функций.

Рассмотрим некоторые из них. Но прежде разберемся, что такое "коллекции".

Коллекциями являются не только списки, но и многие другие типы данных: String, Map, MapSet, Range. Они по-разному устроены, но предоставляют общий АПИ, благодаря которому модуль Enum может работать со всеми ними одинаково.

Этот АПИ называется протокол **Enumerable**. Протоколы мы будем рассматривать позже. Сейчас важно знать, что для разных структуры данных можно реализовать одинаковый протокол, что дает нам полиморфизм. Это похоже на то, как работают интерфейсы в Java.

## sort

Начнем с сортировки. В BEAM любые значения можно сравнивать между собой, даже значения разных типов. Сравнение внутри одного типа удивления не вызывает, но как сравнить атом и кортеж? В BEAM принята некоторая иерархия типов, в рамках которой считается, что любой атом больше любого числа. В целом это выглядит так:

number < atom < reference < function < port < pid < list < tuple < map < bitstring

Так что мы можем сортировать что угодно:

```elixir-iex
> Enum.sort([1, 31, 5, 3.14, 6])
[1, 3.14, 5, 6, 31]
> Enum.sort([:hello, 42, {1, 2}, "world", fn x -> x end, %{:a => 42}, 555])
[
  42,
  555,
  :hello,
  #Function<44.97283095/1 in :erl_eval.expr/5>,
  {1, 2},
  %{a: 42},
  "world"
]
```

Однако, чаще нам нужно сравнивать пользовательские типы данных, для которых нужно указать свои правила сортировки. Например, список пользователей мы хотели бы сортировать по имени. Для этого в Enum.sort нужно передать свою функцию, которая получает два элемента из списка и сообщает, какой из них больше. Функция должна вернуть true, если первый элемент меньше или равен второму, и false, если первый элемент больше второго:

```elixir-iex
> users = HOF.test_data
[
  {:user, 1, "Bob", 23},
  {:user, 2, "Helen", 20},
  {:user, 3, "Bill", 15},
  {:user, 4, "Kate", 14}
]
> sorter = fn({:user, _, name1, _}, {:user, _, name2, _}) -> name1 <= name2 end
#Function<43.97283095/2 in :erl_eval.expr/5>
> Enum.sort(users, sorter)
[
  {:user, 3, "Bill", 15},
  {:user, 1, "Bob", 23},
  {:user, 2, "Helen", 20},
  {:user, 4, "Kate", 14}
]
```

HOF.sort_by/2

HOF.sort_by/3
Здесь используется invert/1 -- функция которая принимает функцию и возвращает функцию. Второе не часто используется на практике. Но вот хороший пример, где это полезно.

## zip

В функциональном программировании не редко встречается задача, когда нужно взять два списка и как-то объединить их элементы попарно. Это делает функция `Enum.zip/2`. В простом варианте она просто соединяет элементы в кортеж:

```elixir-iex
> Enum.zip([1, 2, 3, 4], [:a, :b, :c, :d])
[{1, :a}, {2, :b}, {3, :c}, {4, :d}]
```

Списки могут быть разной длины, тогда zip завершится вместе с коротким списком:

```elixir-iex
> Enum.zip([1, 2], [:a, :b, :c, :d])
[{1, :a}, {2, :b}]
> Enum.zip([1, 2, 3, 4], [:a, :b, :c])
[{1, :a}, {2, :b}, {3, :c}]
```

Иногда мы хотим не просто объединить два элемента в кортеж, но как-то вычислить новый элемент на основе первых двух. Это можно сделать в два прохода -- zip и map:

```elixir-iex
> users
[
  {:user, 1, "Bob", 23},
  {:user, 2, "Helen", 20},
  {:user, 3, "Bill", 15},
  {:user, 4, "Kate", 14}
]
> Enum.zip([10, 20, 30, 40], users)
[
  {10, {:user, 1, "Bob", 23}},
  {20, {:user, 2, "Helen", 20}},
  {30, {:user, 3, "Bill", 15}},
  {40, {:user, 4, "Kate", 14}}
]
> set_id = fn({id, {:user, _, name, age}}) -> {:user, id, name, age} end
#Function<44.97283095/1 in :erl_eval.expr/5>
> Enum.zip([10, 20, 30, 40], users) |> Enum.map(set_id)
[
  {:user, 10, "Bob", 23},
  {:user, 20, "Helen", 20},
  {:user, 30, "Bill", 15},
  {:user, 40, "Kate", 14}
]
```

Но можно использовать функцию Enum.zip_with/3:

```elixir-iex
> set_id = fn(id, {:user, _, name, age}) -> {:user, id, name, age} end
#Function<43.97283095/2 in :erl_eval.expr/5>
> Enum..zip_with([10, 20, 30, 40], users, set_id)
[
  {:user, 10, "Bob", 23},
  {:user, 20, "Helen", 20},
  {:user, 30, "Bill", 15},
  {:user, 40, "Kate", 14}
]
```

Тут есть небольшое отличие: set_id должна принимать два аргумента, а не кортеж из двух элементов. 

## group_by

Еще одна нередкая задача -- сгруппировать элементы списка по какому-нибудь ключу. Собственно, мы это уже делали, когда делили список пользователей на две группы по возрасту.

Сделаем то же самое с помощью Enum.group_by:

```elixir-iex
> users = HOF.test_data
[
  {:user, 1, "Bob", 23},
  {:user, 2, "Helen", 20},
  {:user, 3, "Bill", 15},
  {:user, 4, "Kate", 14}
]
> grouper = fn({:user, _, _, age}) ->
> if age > 16, do: :adult, else: :child
> end
#Function<44.97283095/1 in :erl_eval.expr/5>
> Enum.group_by(users, grouper)
%{
  adult: [{:user, 1, "Bob", 23}, {:user, 2, "Helen", 20}],
  child: [{:user, 3, "Bill", 15}, {:user, 4, "Kate", 14}]
}
```

Для каждого элемента списка функция должна определить, к какому ключу он принадлежит. На выходе получится map, где собраны все ключи, и по каждому ключу можно получить список значений, которые к нему относятся.

## chunk_every

Еще одна полезная функция, которая позволяет разбить список на вложенные списки определенного размера. Это удобно при потоковой обработке входящих данных, когда мы хотим обрабатывать эти данные не по одному элементу, а группами по несколько элементов (батчами, чанками). В определенных случаях это увеличивает пропускную способность канала.

```elixir-iex
> data = [1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
> Enum.chunk_every(data, 3)
[[1, 2, 3], [4, 5, 6]]
> Enum.chunk_every(data, 2)
[[1, 2], [3, 4], [5, 6]]
```

Пример чуть сложнее:

```elixir-iex
> input_bytes = "bla-bla-bla bla-bla bla-bla-bla bla"
"bla-bla-bla bla-bla bla-bla-bla bla"
> input_bytes |> String.to_charlist |> Enum.chunk_every(5)
['bla-b', 'la-bl', 'a bla', '-bla ', 'bla-b', 'la-bl', 'a bla']
```
