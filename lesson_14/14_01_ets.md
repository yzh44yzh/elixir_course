# ETS

## theory

Хранить большие объемы данных внутри состояния GenServer не очень эффективно.

[ETS](https://www.erlang.org/doc/man/ets.html) -- Erlang Term Storage.

Таблица рассчитана на хранение большого объема данных и быстрый доступ к ним.
These provide the ability to store very large quantities of data in an Erlang runtime system, 
and to have constant access time to the data. 
(In the case of ordered_set, see below, access time is proportional to the logarithm of the number of stored objects.)

shared mutable state
мутабельная память, разделяемая между многими процессами

ETS таблицы хранят кортежи произвольного размера, один из элементов которых используется как ключ. По умолчанию это первый элемент. Но при создании ETS можно указать другую позицию элемента-ключа.

Процесс, в котором таблица создана, является ее владельцем. Если процесс завершится (неважно, нормально или из-за ошибки), таблица будет удалена. Владельца можно динамически менять, передавая ответственность за таблицу другому процессу.

ETS таблицы не подвергаются сборке мусора. Программист сам должен следить за тем, чтобы удалять из таблиц ненужные данные. Иначе, постоянно добавляя новые кортежи, но не удаляя ничего из таблицы, он получит утечку памяти.

4 типа таблицы:
- set -- все ключи должны быть уникальны;
- ordered_set -- ключи должны быть уникальны, и кортежи хранятся в сортированном виде;
- bag -- разрешаются кортежи с одинаковыми ключами, но в целом кортежи должны быть разными;
- duplicate_bag -- разрешаются идентичные кортежи.

Тип таблицы по умолчанию -- set.

Тип доступа к таблице:
- public -- любой процесс может писать в таблицу и читать из нее;
- protected -- любой процесс может читать из таблицы, но писать в нее может только процесс-владелец;
- private -- только процесс-владелец может читать и писать.

Тип доступа по умолчанию -- protected.

TODO: концепция владельца ресурса. Позволяет избежать race conditions, и не использовать lock.

Настройка, которая указывает позицию ключа в кортеже: {keypos, K}.

Настройка named_table позволяет обращаться к таблице по имени, а не по id. Это аналогично регистрации процессов.


## CRUD

Создание таблицы:

```elixir-iex
iex(1)> tid = :ets.new(:my_table, [])
#Reference<0.1378260359.1589248005.55860>
```

Write:

```elixir-iex
iex(2)> :ets.insert(tid, {:a, 42})
true
iex(3)> :ets.insert(tid, {:b, 50})
true
iex(4)> :ets.insert(tid, {:c, 100})
true
```

Read:

```elixir-iex
iex(5)> :ets.lookup(tid, :a)
[a: 42]
iex(6)> :ets.lookup(tid, :b)
[b: 50]
iex(7)> :ets.lookup(tid, :c)
[c: 100]
iex(8)> :ets.lookup(tid, :d)
[]
```

`:ets.lookup/2` всегда возвращает список значений, даже если значение только одно. Таблицы разных типов могут иметь одно или больше значений для данного ключа, а API для всех типов одинаковое.

Update:

```elixir-iex
iex(14)> :ets.lookup(tid, :c)
[c: 100]
iex(15)> :ets.insert(tid, {:c, 200})
true
iex(16)> :ets.lookup(tid, :c)
[c: 200]
```

Delete:

```elixir-iex
iex(9)> :ets.delete(tid, :b)
true
iex(10)> :ets.lookup(tid, :b)
[]
```


## match, select

Мы можем использовать сопоставление с образцом (pattern matching), чтобы выбирать нужные данные из таблицы. Синтаксис шаблонов отличается от обычного. И при этом происходит full scan таблицы.

`:ets.match/2` использует простые шаблоны с ограниченными возможностями.
`:ets.select/2` использует сложные шаблоны с широкими возможностями.

match и select для tuple, map, record, struct:

```elixir-iex
iex(1)> SelectData.data_as_tuple()
[
  {:user, 1, "Bob", 42},
  {:user, 2, "Helen", 20},
  {:user, 3, "Bill", 18},
  {:user, 4, "Kate", 15}
]
iex(2)> SelectData.data_as_map()
[
  %{age: 42, id: 1, name: "Bob"},
  %{age: 20, id: 2, name: "Helen"},
  %{age: 18, id: 3, name: "Bill"},
  %{age: 15, id: 4, name: "Kate"}
]
iex(3)> SelectData.data_as_struct()
[
  %Lesson_14.UserS{age: 42, id: 1, name: "Bob"},
  %Lesson_14.UserS{age: 20, id: 2, name: "Helen"},
  %Lesson_14.UserS{age: 18, id: 3, name: "Bill"},
  %Lesson_14.UserS{age: 15, id: 4, name: "Kate"}
]
```

`:ets.fun2ms` -- это один из редких случаев использования макросов в Эрланг. К сожалению, этот макрос не работает в Эликсир.
Мы можем вызвать в консоли iex, но если добавить это в исходники модуля и попытаться скомпилировать, то код не скомпилируется.
Есть альтернативная реализация в виде библиотеки *ex2ms*.

https://github.com/yzh44yzh/practical_erlang/tree/master/06_ets/solution
https://elixirschool.com/ru/lessons/storage/ets


## Консистентность данных

race condition, если таблица public, и в неё пишут много процессов.

Транзакций нет.

Вызовы ets:insert/2 и ets:delete/2 выполняются атомарно и изолированно. 
Атомарно -- это значит, что операция либо завершится успешно, либо будет отменена, промежуточные состояния не останутся в таблице. 
Изолированно -- это значит, что другие процессы при чтении из таблицы не будут видеть промежуточных состояний.

При выборке с помощью match/select гарантируется, что каждый кортеж будет рассмотрен, и рассмотрен только один раз. 
Но если во время обхода/выборки будут вставлены новые кортежи, то они могут быть рассмотрены, а могут быть пропущены. Для них гарантий нет.


## LRU Cache 1

```elixir-iex
iex(1)> LRU_Cache.start_link([])
{:ok, #PID<0.118.0>}
iex(2)> LRU_Cache.get(:a)
{:error, :not_found}
iex(3)> LRU_Cache.put(:a, 42)
:ok
iex(4)> LRU_Cache.get(:a)
{:ok, 42}
```

Преимущество: запись в процессе сервера, чтение в процессе клиента.
Сервер не является узким местом, если много процессов часто читают данные из таблицы.

Недостаток: утечка памяти на невостребованных ключах.
Ключи удаляются только если их запрашивают.
Нет никакого автоматического очищения таблицы, всё нужно удалять явно.


## LRU Cache 2

Преимущество: нет утечки памяти.

Недостаток: и запись, и чтение работают через сервер. Нет возможности установить lifetime per key.
Сервер можно шардировать.
lifetime per key можно реализовать, если он меньше чем lifetime per cache.


## DETS

Disk EST

Модуль DETS предлагает аналогичный API, как и ETS. По понятным причинам он работает медленнее.
